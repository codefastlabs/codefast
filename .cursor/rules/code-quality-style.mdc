---
alwaysApply: true
description: Code quality standards and style guidelines
---

# Code Quality Standards and Style Guidelines

## Core Quality Principles

This project maintains **zero-tolerance** policies for quality issues:

### Absolute Requirements
- **Zero ESLint warnings** - `pnpm lint` must pass completely
- **Zero TypeScript errors** - `pnpm check-types` must succeed
- **100% test success** - `pnpm test` must pass all tests
- **Successful builds** - `pnpm build` must complete without errors

## Style Guidelines

### Code Formatting
- **Prettier** handles all formatting automatically
- Configuration in [prettier.config.js](mdc:prettier.config.js)
- Includes plugins for package.json and Tailwind CSS
- Run `pnpm format` to auto-format, `pnpm format:check` to verify

### Naming Conventions
```typescript
// Components: PascalCase
export const UserProfile: React.FC<UserProfileProps> = () => {};

// Hooks: camelCase with 'use' prefix
export const useLocalStorage = () => {};

// Utilities: camelCase
export const formatCurrency = (amount: number) => {};

// Constants: SCREAMING_SNAKE_CASE
export const API_BASE_URL = 'https://api.example.com';

// Types/Interfaces: PascalCase
export interface UserPreferences {
  theme: 'light' | 'dark';
}
```

### File Naming
- **Components**: `ComponentName.tsx`
- **Hooks**: `useHookName.ts`
- **Utilities**: `descriptive-name.ts`
- **Tests**: `ComponentName.test.tsx` or `utility.test.ts`
- **Types**: `types.ts` or `ComponentName.types.ts`

## Content Guidelines

### Emoji Policy
**CRITICAL**: **No emojis** are allowed in:
- Source code files
- Console logs
- Comments
- Documentation strings
- Variable names
- Function names
- Any code-related content

Use descriptive text instead of emojis for better accessibility and professionalism.

### Comments and Documentation
```typescript
/**
 * Formats a date string according to the specified locale and options.
 * 
 * @param date - The date to format
 * @param locale - The locale to use for formatting (default: 'en-US')
 * @param options - Intl.DateTimeFormat options
 * @returns The formatted date string
 */
export const formatDate = (
  date: Date,
  locale = 'en-US',
  options: Intl.DateTimeFormatOptions = {}
): string => {
  return new Intl.DateTimeFormat(locale, options).format(date);
};
```

## TypeScript Quality Standards

### Type Safety
- **Never use `any`** - Always provide explicit types
- **Minimize `unknown` usage** - Prefer explicit typing and type inference
- **Strict null checks** - Handle undefined/null cases explicitly
- **Generic constraints** - Use proper type bounds

```typescript
// Good: Explicit typing
interface ApiResponse<T> {
  data: T;
  status: 'success' | 'error';
  message?: string;
}

// Good: Proper generic constraints
function processItems<T extends { id: string }>(items: T[]): T[] {
  return items.filter(item => item.id.length > 0);
}

// Bad: Using any
function processData(data: any): any { // ‚ùå Never do this
  return data;
}
```

### Import Organization
```typescript
// 1. Node modules
import React from 'react';
import { clsx } from 'clsx';

// 2. Internal packages (workspace)
import { Button } from '@codefast/ui';
import { useLocalStorage } from '@codefast/hooks';

// 3. Relative imports (same package)
import { formatDate } from '../utils/date';
import type { ComponentProps } from './types';
```

## Performance Standards

### Bundle Optimization
- **Tree-shakeable exports** - Use named exports
- **Minimal dependencies** - Avoid unnecessary packages
- **Dynamic imports** - Use for code splitting when appropriate
- **TypeScript strict mode** - Enables better optimization

### React Best Practices
```typescript
// Good: Proper memo usage
export const ExpensiveComponent = React.memo<Props>(({ data }) => {
  const processedData = useMemo(() => processData(data), [data]);
  
  const handleClick = useCallback((id: string) => {
    onItemClick(id);
  }, [onItemClick]);
  
  return <div>{/* Component JSX */}</div>;
});

// Good: Proper prop types
interface ComponentProps {
  title: string;
  onSubmit: (data: FormData) => void;
  isLoading?: boolean;
}
```

## Error Handling

### Consistent Error Patterns
```typescript
// Good: Explicit error handling
export const fetchUserData = async (id: string): Promise<User | null> => {
  try {
    const response = await fetch(`/api/users/${id}`);
    
    if (!response.ok) {
      throw new Error(`Failed to fetch user: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching user data:', error);
    return null;
  }
};
```

Quality gates are enforced through automated tooling and must pass before any code can be merged or released.