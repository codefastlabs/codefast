---
description: Comprehensive TypeScript Best Practices for Type-Safe and Maintainable Code (TypeScript 5.9+)
globs:
  - "**/*.ts"
  - "**/*.tsx"
alwaysApply: true
---
# TypeScript Best Practices

Adhere to these TypeScript best practices for robust, type-safe, and maintainable code, aligned with the project's `tsconfig.json` (`@file ../tsconfig.json`). Leverage TypeScript 5.9+ features (e.g., deferred imports, improved inference, scaffolding) to enhance performance and developer experience. Prioritize type safety, readability, and modern patterns while balancing explicitness with inference.

## 1. Core TypeScript Guidelines
- Use the latest TypeScript version (5.9+ as specified in `package.json`).
- Configure `tsconfig.json` with `"target": "ESNext"`, `"module": "ESNext"`, and `strict: true` (enabling `noImplicitAny`, `strictNullChecks`, `strictFunctionTypes`).
- Prefer type inference for return types and simple variables when unambiguous; use explicit types for public APIs or complex logic.
- Avoid `any`; use `unknown` for unsafe inputs and narrow promptly.
- Prefer type aliases for complex types (unions, intersections, conditionals); use interfaces for simple, extendable object shapes.
- Use TSDoc/JSDoc for public APIs and complex types; integrate with Typedoc for documentation.
- Trade-off: Inference reduces boilerplate but may obscure intent in large teams; explicit types improve clarity but can be verbose.

## 2. Generic Types with Constraints
- Use generics for reusable functions, interfaces, or classes; apply `extends` for type safety.
- Leverage TS 5.9's improved inference for generics in promises and arrays.
- Trade-off: Generics enhance flexibility but may increase complexity—use when reuse is justified.

## 3. Conditional Types and Mapped Types
- Use conditional types for dynamic type logic; mapped types for property transformations.
- Prefer built-in utilities: `Partial<T>`, `Pick<T, K>`, `Omit<T, K>`, `Readonly<T>`.
- TS 5.9: Enhanced `infer` in conditionals and better handling in deferred contexts.

## 4. Template Literal Types
- Generate dynamic string types for keys or discriminated unions.
- Combine with utilities like `Capitalize`, `Uppercase`.

## 5. Advanced Utility Types
- Leverage `Exclude<T, U>`, `Extract<T, U>`, `NonNullable<T>`, `ReturnType<T>`, `Awaited<T>`, `Parameters<T>`.
- Use `satisfies` (TS 4.9+) to validate types without widening.
- TS 5.9: Improved `Awaited` for deferred promises.

## 6. Type Guards and Type Predicates
- Narrow types with `typeof`, `instanceof`, `in`, or custom predicates.
- Use `satisfies` for inline validation.

## 7. Discriminated Unions
- Model variants with a common discriminant; ensure exhaustive checks with `never`.
- TS 5.9: Better inference in switch statements.

## 8. Branded Types for Type Safety
- Use for nominal typing to distinguish same-structured types.
- Trade-off: Adds safety but requires casting—use sparingly.

## 9. Exact Types and Readonly Arrays
- Use `as const` for literal types; `readonly` for immutable arrays.
- TS 5.9: Improved array inference.

## General Guidelines
- Align with `tsconfig.json` (e.g., `strict: true`, `target: "ESNext"`).
- Use type aliases for complex types, interfaces for extendable objects.
- Document with TSDoc; enforce with ESLint (`@typescript-eslint`) and Typedoc.
- Adopt TS 5.9 features: deferred imports (`import defer`) for lazy loading, improved scaffolding (`tsc --init --scaffold`), and enhanced error reporting.
- Trade-offs:
  - Type aliases are more flexible for unions/intersections; interfaces support declaration merging.
  - Explicit types clarify intent in public APIs; inference reduces boilerplate for internal code.
- Integrate with modern tools: Use ESLint for linting, Prettier for formatting, and Vite/Bun for ESM bundling.
- Avoid outdated patterns: No `any`, minimal `unknown`, no redefinition of built-in utilities.
