import { logger } from '@codefast/ui';
import { promises as fs } from 'node:fs';
import path from 'node:path';
import { rimraf } from 'rimraf';
import { z } from 'zod';

import type { Registry } from '@/scripts/lib/schema';

import { blocks } from '@/registry/registry-blocks';
import { charts } from '@/registry/registry-charts';
import { registryItemSchema } from '@/scripts/lib/schema';

const DEPRECATED_ITEMS = new Set<string>([]);

const registry = {
  name: 'shadcn/ui',
  homepage: 'https://ui.shadcn.com',
  items: z.array(registryItemSchema).parse(
    [
      {
        name: 'index',
        type: 'registry:style',
        dependencies: ['tailwindcss-animate', 'class-variance-authority', 'lucide-react'],
        registryDependencies: ['utils'],
        tailwind: {
          config: {
            plugins: [`require("tailwindcss-animate")`],
          },
        },
        cssVars: {},
        files: [],
      },
      ...blocks,
      ...charts,
      {
        name: 'use-mobile',
        type: 'registry:hook',
        files: [
          {
            path: 'hooks/use-mobile.ts',
            type: 'registry:hook',
          },
        ],
      },
      {
        name: 'products-01',
        description: 'A table of products',
        type: 'registry:block',
        registryDependencies: ['checkbox', 'badge', 'button', 'dropdown-menu', 'pagination', 'table', 'tabs', 'select'],
        files: [
          {
            path: 'blocks/products-01/page.tsx',
            type: 'registry:page',
            target: 'app/products/page.tsx',
          },
          {
            path: 'blocks/products-01/components/products-table.tsx',
            type: 'registry:component',
          },
        ],
      },
    ].filter((item) => {
      return !DEPRECATED_ITEMS.has(item.name);
    }),
  ),
} satisfies Registry;

async function buildRegistryIndex(): Promise<void> {
  let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import type { JSX, LazyExoticComponent } from 'react';

import { lazy } from 'react';

interface RegistryFile {
  path: string;
  target: string;
  type: string;
}

interface RegistryItem {
  component: LazyExoticComponent<() => JSX.Element> | null;
  description: string;
  files: RegistryFile[];
  meta: undefined;
  name: string;
  registryDependencies: string[];
  type: string;
}

type Registry = Record<string, RegistryItem>;

export const Index: Registry = {`;

  for (const item of registry.items) {
    const resolveFiles = item.files?.map((file) => `registry/${file.path}`);

    if (!resolveFiles) {
      continue;
    }

    const componentPath = item.files?.[0]?.path ? `@/registry/${item.files[0].path}` : '';

    index += `
  "${item.name}": {
    name: "${item.name}",
    description: "${item.description ?? ''}",
    type: "${item.type}",
    registryDependencies: ${JSON.stringify(item.registryDependencies)},
    files: [
      ${item.files?.map((file) => {
        const filePath = `registry/${typeof file === 'string' ? file : file.path}`;
        const resolvedFilePath = path.resolve(filePath);

        return typeof file === 'string'
          ? `"${resolvedFilePath}"`
          : `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ''}"
      }`;
      })}
    ],
    component: ${
      componentPath
        ? `lazy(async () => {
      const mod = await import("${componentPath}")
      const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object');

      return { default: mod.default || mod[exportName] }
    })`
        : 'null'
    },
    meta: ${JSON.stringify(item.meta)},
  },`;
  }

  index += `
  }`;

  // Write a style index.
  rimraf.sync(path.join(process.cwd(), 'src', '__registry__/index.tsx'));
  await fs.writeFile(path.join(process.cwd(), 'src', '__registry__/index.tsx'), index);
}

try {
  logger.log('üóÇÔ∏è Building registry/__index__.tsx...');
  await buildRegistryIndex();

  logger.log('üèóÔ∏è Building registry...');
} catch (error) {
  logger.error(error);
  process.exit(1);
}
