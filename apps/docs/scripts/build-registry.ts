import { logger } from '@codefast/ui';
import { promises as fs } from 'node:fs';
import path from 'node:path';
import { rimraf } from 'rimraf';

import type { Registry } from '@/scripts/lib/schema';

import { registry } from '@/registry';

// Constants
const REGISTRY_FILE_PATH = path.join(process.cwd(), 'src', '__registry__/index.tsx');
const FILE_HEADER = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.`;
// Registry configuration

function createComponentImport(componentPath: string): string {
  return `lazy(async () => {
    const mod = await import("${componentPath}")
    const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object');

    return { default: mod.default || mod[exportName] }
  })`;
}

function generateRegistryContent(registryItems: Registry['items']): string {
  let content = `${FILE_HEADER}
import type { JSX, LazyExoticComponent } from 'react';

import { lazy } from 'react';

interface RegistryFile {
  path: string;
  target: string;
  type: string;
}

interface RegistryItem {
  component: LazyExoticComponent<() => JSX.Element> | null;
  description: string;
  files: RegistryFile[];
  meta: undefined;
  name: string;
  registryDependencies: string[];
  type: string;
}

type Registry = Record<string, RegistryItem>;

export const Index: Registry = {`;

  for (const item of registryItems) {
    const resolveFiles = item.files?.map((file) => file.path);

    if (!resolveFiles) {
      content += `
  "${item.name}": {
    name: "${item.name}",
    description: "${item.description ?? ''}",
    type: "${item.type}",
    meta: ${JSON.stringify(item.meta)},
  },`;
      continue;
    }

    const componentPath = item.files?.[0]?.path ?? '';

    content += `
  "${item.name}": {
    name: "${item.name}",
    description: "${item.description ?? ''}",
    type: "${item.type}",
    registryDependencies: ${JSON.stringify(item.registryDependencies)},
    files: [
      ${item.files?.map((file) => {
        const filePath = typeof file === 'string' ? file : file.path;
        const resolvedFilePath = path.resolve(filePath);

        return typeof file === 'string'
          ? `"${resolvedFilePath}"`
          : `{
              path: "${filePath}",
              type: "${file.type}",
              target: "${file.target ?? ''}"
            }`;
      })}
    ],
    component: ${componentPath ? createComponentImport(componentPath) : 'null'},
    meta: ${JSON.stringify(item.meta)},
  },`;
  }

  return `${content}\n}`;
}

async function buildRegistryIndex(): Promise<void> {
  try {
    logger.log(`üóÇÔ∏è Building ${REGISTRY_FILE_PATH}...`);

    const registryContent = generateRegistryContent(registry.items);

    await rimraf(REGISTRY_FILE_PATH);
    await fs.writeFile(REGISTRY_FILE_PATH, registryContent);

    logger.log('üèóÔ∏è Building registry...');
  } catch (error) {
    logger.error('Failed to build registry:', error);
    process.exit(1);
  }
}

await buildRegistryIndex();
